import numpy as np
import scipy
from scipy.special import lambertw
from scipy.optimize import curve_fit

def acc_alpha_beta(V: np.array, V_test: np.array, a0, b0, m: np.array, tau: np.array,
                   alpha: np.array, beta: np.array):
    """
    Оценивает точность восстановления скоростей переходов alpha и beta по данным (m, tau)
    с использованием параметризации через квазилинейную замену.

    Параметры:
    ----------
    V : np.array
        Вектор мембранных потенциалов (или напряжений), соответствующий оригинальным данным.
    V_test : np.array
        Потенциалы, по которым вычисляются тестовые значения (может быть тем же, что и V).
    a0 : array-like (2 элемента)
        Набор коэффициентов для аффинного преобразования (наклоны) — [a_beta, a_alpha].
    b0 : array-like (2 элемента)
        Набор коэффициентов для аффинного преобразования (сдвиги) — [b_beta, b_alpha].
    m : np.array
        Наблюдаемые значения активации (например, m∞).
    tau : np.array
        Наблюдаемые значения постоянных времени (например, tau_m).
    alpha : np.array
        Эталонные значения функции alpha(V) для сравнения.
    beta : np.array
        Эталонные значения функции beta(V) для сравнения.

    Возвращает:
    -----------
    Delta_alpha : float
        Среднекорневая ошибка между эталонной alpha и восстановленной alpha1, с поправкой на производную.
    Delta_beta : float
        Среднекорневая ошибка между эталонной beta и восстановленной beta1, с поправкой на производную.
    Delta_m : float
        Среднекорневая ошибка между m и m1 = alpha1 / (alpha1 + beta1).
    Delta_tau : float
        Среднекорневая ошибка между tau и tau1 = 1 / (alpha1 + beta1).

    Примечание:
    -----------
    Используется квазилинейная аппроксимация:
        alpha(V) ≈ u_alpha / (1 - exp(-u_alpha)), где u_alpha = a_alpha * V + b_alpha  
        beta(V) ≈ exp(-u_beta), где u_beta = a_beta * V + b_beta

    """   

def find_Boltsman_from_exp_data(m_: np.array, V_m_: np.array):
    """
    Находит параметры  функции Больцмана по экспериментальным данным (m vs V).
    Функция решает линейную задачу наилучшего приближения  вероятности открытия канала (активации) и извлекает параметры сдвига и крутизны.
    Параметры:
    ----------
    m_ : np.array
        Вектор экспериментальных значений вероятности открытия (m), таких что 0 < m < 1.
    V_m_ : np.array
        Соответствующие мембранные потенциалы (в милливольтах), при которых были измерены значения m.

    Возвращает:
    -----------
    V0 : float
        Параметр сдвига (V₀) — потенциал, при котором вероятность открытия составляет 0.5.
    s : float
        Параметр крутизны — обратный температурному коэффициенту (характеризует резкость перехода).

    Математика:
    -----------
    Считается, что зависимость m∞(V) подчиняется функции Больцмана:
        m(V) = 1 / (1 + exp(-(V - V₀)/s))

    Тогда логит:
        logit(m) = ln(m / (1 - m)) = (V - V₀) / s  → линейное уравнение

    Метод:
    ------
    Логит-преобразование → линейная регрессия по формуле наименьших квадратов:
        ln(m / (1 - m)) = s⁻¹ * V - s⁻¹ * V₀

    Примечание:
    -----------
    - Значения m должны быть строго между 0 и 1 (не 0 и не 1);
    - Лучше работает при предварительном сглаживании m(V);
    - Предназначена для неаппроксимированных экспериментальных данных.
    """
    # Calculation of parameters
    m_clipped = np.clip(m_, eps, 1 - eps)  # Защита от 0 и 1
    logit_m = np.log(m_clipped / (1 - m_clipped))  # логит-преобразование

    # Формируем матрицу линейной регрессии: logit_m = s⁻¹ * V - s⁻¹ * V₀
    A = np.vstack((V_m_, np.ones_like(V_m_))).T
    coeffs, _, _, _ = np.linalg.lstsq(A, logit_m, rcond=None)

    s_inv, b = coeffs
    s = 1 / s_inv
    V0 = -b * s

    return V0, s

def find_aa_bb_by_mnk(alpha_: np.array, beta_: np.array, V_: np.array):
    """
    Поиск параметров квазилинейной замены (аффинной аппроксимации) для функций alpha(V) и beta(V)
    методом наименьших квадратов (МНК).

    Функция вычисляет преобразованные аргументы u_alpha и u_beta, соответствующие аппроксимации:
        alpha(V) ≈ u_alpha / (1 - exp(-u_alpha))
        beta(V)  ≈ exp(-u_beta)
    и затем подбирает линейные преобразования:
        u_alpha ≈ a_alpha * V + b_alpha
        u_beta  ≈ a_beta * V + b_beta

    Параметры:
    ----------
    alpha_ : np.array
        Значения функции alpha(V) на заданной сетке потенциалов V_.
    beta_ : np.array
        Значения функции beta(V) на той же сетке V_.
    V_ : np.array
        Вектор мембранных потенциалов, соответствующих данным alpha_ и beta_.

    Возвращает:
    -----------
    a0 : np.array, shape=(2,)
        Угловые коэффициенты линейной аппроксимации [a_beta, a_alpha].
    b0 : np.array, shape=(2,)
        Смещения линейной аппроксимации [b_beta, b_alpha].

    Примечания:
    -----------
    - Для обратного восстановления u_alpha используется ветвь k=1 функции Ламберта W,
      соответствующая биофизически осмысленному решению (неотрицательное u).
    - Оценка проводится по формуле линейной регрессии:
        a = cov(x, y) / var(x)
        b = mean(y) - a * mean(x)

    - Эта процедура применяется при построении квазилинейной модели Ходжкина–Хаксли для
      упрощения представления скоростей переходов и последующей идентификации параметров.

    """
    # Inverse functions
    u = np.zeros((2, len(alpha_)))  # Initialize u
    u[0,:] = -np.log(beta_)
    argFun = -alpha_ * np.exp(-alpha_)  # Argument for Lambert W function
    u[1,:] = alpha_ + lambertw(argFun, k=1).real 
    # MNK (Method of Least Squares)
    x = np.array(V_)
    a0 = np.zeros(2)
    b0 = np.zeros(2)
    for i in range(2):
        y = u[i]
        E_xy = np.mean(x * y)
        E_xx = np.mean(x ** 2)
        E_x = np.mean(x)
        E_y = np.mean(y)

        covXY = E_xy - E_x * E_y
        covXX = E_xx - E_x * E_x

        a0[i] = covXY / covXX
        b0[i] = E_y - a0[i] * E_x
    return a0, b0

    